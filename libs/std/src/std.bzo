Std #Module










"Signed Integers"
Int :: (I8, I16, I32, I64)
I8  :: #Int8
I16 :: #Int16
I32 :: #Int32
I64 :: #Int64

"Unsigned Integers"
Unt :: (U8, U16, U32, U64)
U8  :: #Uint8
U16 :: #Uint16
U32 :: #Uint32
U64 :: #Uint64

"Floating Point"
Flt :: (F16, F32, F64)
F16 :: #Flt16
F32 :: #Flt32
F64 :: #Flt64

"Posits"
Pst :: (P8, P16, P32, P64)
P8  :: #Pst8
P16 :: #Pst16
P32 :: #Pst32
P64 :: #Pst64

Num  :: (Int, Unt, Flt, Unm)

Real :: (Flt, Pst)

Discrete :: (Int, Unt)


Sld  :: (S8, S16, S32, S64, S128, S256, S512)
S8   :: #S8
S16  :: #S16
S32  :: #S32
S64  :: #S64
S128 :: #S128
S256 :: #S256
S512 :: #S512


Bl :: (True.[], False.[]) #BoolTF

Any :: #Any


[N'.Num] + :: [N', N'] ;; N'
+ :: #add-binop

[N'.Num] - :: [N', N'] ;; N'
- :: #sub-binop

[N'.Num] * :: [N', N'] ;; N'
* :: #mul-binop

[N'.Num] / :: [N', N'] ;; N'
/ :: #div-binop

[N'.Num] % :: [N', N'] ;; N'
% :: #mod-binop


[N'.Num] >  :: [N', N'] ;; Bl
>  :: #gtr-binop

[N'.Num] <  :: [N', N'] ;; Bl
<  :: #lss-binop

[N'.Num] >= :: [N', N'] ;; Bl
>= :: #geq-binop

[N'.Num] =< :: [N', N'] ;; Bl
=< :: #leq-binop

[N'.Num] =  :: [N', N'] ;; Bl
=  :: #eql-binop

[N'.Num] != :: [N', N'] ;; Bl
!= :: #neq-binop


!! :: Bl ;; Bl
[True ] !! :: False
[False] !! :: True

&& :: [Bl, Bl] ;; Bl
[True, True] && :: True
[x,    y   ] && :: False

|| :: [Bl, Bl] ;; Bl
[False, False] || :: False
[x,     y    ] || :: True

? :: [Bl, A', B'] ;; (A', B')
[True,  x, _] ? :: x
[False, _, y] ? :: y

!? :: [Bl, A', B'] ;; (A', B')
[True,  _, y] !? :: y
[False, x, _] !? :: x

[T'] Maybe :: (Just.T', Nothing.[])

[A', B'] Either :: (Left.A', Right.B')


[N'.Num] inc :: N' ;; N'
inc :: 1`+

[N'.Num] dec :: N' ;; N'
dec :: 1`-

[N'.Num] *2 :: N' ;; N'
*2 :: 2`*

[N'.Num] /2 :: N' ;; N'
/2 :: 2`*

[N'.Num] *3 :: N' ;; N'
(x) *3 :: [x, x *2]+

[N'.Num] /3 :: N' ;; N'
/3 :: 3`/

[N'.Num] %2 :: N' ;; N'
%2 :: 2`%

[N'.Num] %3 :: N' ;; N'
%3 :: 3`%

[N'.Num] ^2 :: N' ;; N'
[x] ^2 :: [x, x]*

[N'.Num] ^3 :: N' ;; N'
[x] ^3 :: [x, x ^2]*



[S'.Sld, N'.Integral] |+ :: [S', N'] ;; S'
|+ :: #slideInsert

[S'.Sld, N'.Integral] |- :: [S', N'] ;; S'
|- :: #slideRemove

[S'.Sld, N'.Integral] |= :: [S', N'] ;; S'
|= :: #slideRead

[S'.Sld, N'.Integral] |? :: [S', N'] ;; Bl
|? :: #slideComp

[S'.Sld, N'.Integral] |?!:: [S', N'] ;; Bl
|?!:: |? !!


[S'.Sld] || :: [S', S'] ;; S'
|| :: #slideUnion

[S'.Sld] && :: [S', S'] ;; S'
|& :: #slideIntersection

[S'.Sld] ^^ :: [S', S'] ;; S'
|^ :: #slideDifference

[S'.Sld] !! :: S' ;; S'
|! :: #slideInverse



fail! :: () ;; Any
fail! :: #fail!
