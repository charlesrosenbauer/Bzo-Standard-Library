Std #Module










"Signed Integers"
Int :: (I8, I16, I32, I64)
I8  :: #Int8
I16 :: #Int16
I32 :: #Int32
I64 :: #Int64

"Unsigned Integers"
Unt :: (U8, U16, U32, U64)
U8  :: #Unt8
U16 :: #Unt16
U32 :: #Unt32
U64 :: #Unt64

"Floating Point"
Flt :: (F16, F32, F64)
F16 :: #Flt16
F32 :: #Flt32
F64 :: #Flt64

"John Gustafson's Unums, because we need associative floats"
Unm :: (N16, N32, N64)
N16 :: #Unm16
N32 :: #Unm32
N64 :: #Unm64

Num  :: (Int, Unt, Flt, Unm)

Real :: (Flt, Unm)

Discrete :: (Int, Unt)

Bl :: (True:(), False:()) #BoolTF

Any :: #Any


(N':Num) + :: (N'. N') ;; N'
+ :: #add-binop

(N':Num) - :: (N'. N') ;; N'
- :: #sub-binop

(N':Num) * :: (N'. N') ;; N'
* :: #mul-binop

(N':Num) / :: (N'. N') ;; (N', ())
(x. 0) / :: ()
/ :: #div-binop

(N':Num) % :: (N'. N') ;; N'
% :: #mod-binop


(N':Num) >  :: (N'. N') ;; Bl
>  :: #gtr-binop

(N':Num) <  :: (N'. N') ;; Bl
<  :: #lss-binop

(N':Num) >= :: (N'. N') ;; Bl
>= :: #geq-binop

(N':Num) =< :: (N'. N') ;; Bl
=< :: #leq-binop

(N':Num) =  :: (N'. N') ;; Bl
=  :: #eql-binop

(N':Num) != :: (N'. N') ;; Bl
!= :: #neq-binop

!! :: Bl ;; Bl
(True ) !! :: False
(False) !! :: True

&& :: (Bl. Bl) ;; Bl
(True. True) && :: True
(x.    y   ) && :: False

|| :: (Bl. Bl) ;; Bl
(False. False) || :: False
(x.     y    ) || :: True

? :: (Bl. A'. B') ;; (A', B')
(True.  x. _) ? :: x
(False. _. y) ? :: y

!? :: (Bl. A'. B') ;; (A', B')
(True.  _. y) !? :: y
(False. x. _) !? :: x

(T') Maybe :: (Just:T', Nothing:())

(A'. B') Either :: (Left:A', Right:B')










(N':Num) inc :: N' ;; N'
inc :: 1`+

(N':Num) dec :: N' ;; N'
dec :: 1`-

(N':Num) *2 :: N' ;; N'
*2 :: 2`*

(N':Num) /2 :: N' ;; N'
/2 :: 2`*

(N':Num) *3 :: N' ;; N'
(x) *3 :: (x. x *2)+

(N':Num) /3 :: N' ;; N'
/3 :: 3`/

(N':Num) %2 :: N' ;; N'
%2 :: 2`%

(N':Num) %3 :: N' ;; N'
%3 :: 3`%

(N':Num) ^2 :: N' ;; N'
(x) ^2 :: (x. x)*

(N':Num) ^3 :: N' ;; N'
(x) ^3 :: (x. x ^2)*


fail! :: () ;; Any
fail! :: #fail!
